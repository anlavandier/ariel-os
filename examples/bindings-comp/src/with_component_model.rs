pub use ariel_os_bindings::wasm::rng::with_component_model::{self, ArielRngHost, Host as RngHost};

use wasmtime::{Config, Engine, Store};
use wasmtime::component::{bindgen, Linker, Component, HasSelf};

use super::info;

bindgen!({
    // Folder containing the WIT file
    path: "wit",
    // World to target
    world: "example-world",
    // Tell the macro where the ariel:binding/rng-api is defined
    with: {
        "ariel:bindings/rng-api": with_component_model,
    }
});

#[derive(Debug, Default)]
pub struct MyHost{
    ariel_host: ArielRngHost,
}

impl RngHost for MyHost {
    fn next_u32(&mut self,) -> u32 {
        self.ariel_host.next_u32()
    }
    fn next_u64(&mut self,) -> u64 {
        self.ariel_host.next_u64()
    }
    fn random_bytes(&mut self,len:u32,) -> wasmtime::component::__internal::Vec<u8> {
        self.ariel_host.random_bytes(len)
    }
}


///
/// # Panics
///
/// # Errors
///
pub fn run_wasm() -> wasmtime::Result<u64> {
    info!("Using the component Model bindings");
    // Configuration used when precompiling the component
    let mut config = Config::default();
    config.max_wasm_stack(2048);
    config.wasm_custom_page_sizes(true);
    config.target("pulley32")?;
    config.memory_reservation(0);
    config.memory_init_cow(false);
    config.memory_reservation_for_growth(0);
    config.memory_may_move(false);
    let engine = Engine::new(&config)?;

    // Create a runtime `Module` from a Wasm program that was pre-compiled and
    // written to the `add.cwasm` file by `wasmtime/examples/pre_compile.rs`.
    //
    // **Warning:** Wasmtime does not (and in general cannot) fully validate
    // pre-compiled modules for safety -- only create `Module`s and `Component`s
    // from pre-compiled bytes you control and trust! Passing unknown or
    // untrusted bytes will lead to arbitrary code execution vulnerabilities in
    // your system!
    let component_bytes  = include_bytes!("../payload_component_model.cwasm");

    let component = match unsafe { Component::deserialize_raw(&engine, component_bytes.as_slice().into()) } {
        Ok(comp) => comp,
        Err(error) => {
            return Err(error);
        }
    };

    let mut store: Store<MyHost> = Store::new(&engine, MyHost::default());

    let mut linker = Linker::new(&engine);

    // Generated by bindgen!()
    ExampleWorld::add_to_linker::<MyHost, HasSelf<MyHost>>(&mut linker, |state| {state})?;
    let bindings = ExampleWorld::instantiate(&mut store, &component, &linker)?;

    let sum = bindings.call_start(&mut store).unwrap();

    Ok(sum)
}





// Same as https://github.com/bytecodealliance/wasmtime/blob/main/examples/min-platform/embedding/wasmtime-platform.c
// I have no idea whether this is safe or not.
// https://github.com/bytecodealliance/wasmtime/blob/aec935f2e746d71934c8a131be15bbbb4392138c/crates/wasmtime/src/runtime/vm/traphandlers.rs#L888
static mut TLS_PTR: u32 = 0;
#[unsafe(no_mangle)]
extern "C" fn wasmtime_tls_get() -> *mut u8 {
    unsafe { TLS_PTR as *mut u8 }
}

#[unsafe(no_mangle)]
extern "C" fn wasmtime_tls_set(val: *const u8) {
   unsafe { TLS_PTR = val as u32 };
}
